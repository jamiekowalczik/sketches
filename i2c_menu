//Import this phenominal library
#include <EnableInterrupt.h>
#include <EEPROM.h>
#include <SPI.h>
#include "nRF24L01.h"
#include "RF24.h"
#include "printf.h"
#include <stdio.h>

#include "Thread.h"

#include <OneWire.h>
#include <DallasTemperature.h>

//#include <HardwareSerial.h>
#include <Wire.h> 
#include <LiquidCrystal_I2C.h>
#include <menu.h>//menu macros and objects
//#include <pcint.h>
//#include <quadEncoder.h>
#include <genericKeyboard.h>
//#include <keyStream.h>
//#include <chainStream.h>
#include <menuLCDs.h>//F. Malpartida LCD's
#include <menuFields.h>
#include "RTClib.h"

//Variables containing data we want to keep persistent
int lastConfigID;
int ConfigID;

//Variables for reading/writing persistent data
//Vars for reading & writing settings
byte xeeConfigID;
int addrConfigID = 1;

// Pin Definitions
#define pinEnter A3
#define keyboard_AnalogInput 3

#define btnRIGHT  menu::enterCode
#define btnUP     menu::downCode
#define btnDOWN   menu::upCode
#define btnLEFT   menu::escCode
#define btnENTER  menu::enterCode
#define btnNONE   -1

#define depthHighPin A2
#define depthHighID 2

LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);  // Set the LCD I2C address
menuLCD menu_lcd(lcd,20,4);//menu output device

void nothing() {}

#define ONE_WIRE_BUS 4

RTC_DS1307 rtc;    // Create a RealTimeClock object

/*-----( Declare objects )-----*/
/* Set up a oneWire instance to communicate with any OneWire device*/
OneWire ourWire(ONE_WIRE_BUS);

/* Tell Dallas Temperature Library to use oneWire Library */
DallasTemperature sensors(&ourWire);

Thread t_checkWaterTemp = Thread();
Thread t_checkWaterDepth = Thread();

void saveConfigID(int i) {
  xeeConfigID = byte(i);
  EEPROM.write(addrConfigID,xeeConfigID);
}

void readConfig() {
  xeeConfigID = EEPROM.read(addrConfigID);
  ConfigID = int(xeeConfigID);
  if (ConfigID < 0 || ConfigID >99){
     ConfigID = 0;
  }
  lastConfigID = ConfigID;
}

void updateConfigID() {
  if (ConfigID != lastConfigID) {
    saveConfigID(ConfigID);
    lastConfigID = ConfigID;
  }
}

void emptyCmd() {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Emptying Reservoir");
  delay(1000);
  lcd.setCursor(0,1);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.setCursor(0,2);
  lcd.print(" ****Completed****  ");
}

void fillCmd() {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Filling Reservoir");
  delay(1000);
  lcd.setCursor(0,1);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.setCursor(0,2);
  lcd.print(" ****Completed****  ");
}

String str1="Room Temp: ";
String str2="74 F";
String concatStr=str1+str2;

//prompt sub1(str1,nothing);
//prompt* subMenuData[]={&sub1};
//menu subMenu("Sub-menu",1,subMenuData);


void showSensorInfo() {
  menu_lcd.clear();
  menu_lcd.setCursor(0,0);
  menu_lcd.print("Room Temp: ");
  menu_lcd.print(" F");
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Filling Reservoir");
  delay(1000);
  lcd.setCursor(0,1);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.setCursor(0,2);
  lcd.print(" ****Completed****  ");
}

MENU(showSensorData,"Sensor Data",
   OP("Water Level: ",nothing),
   OP("Water Temp: ",nothing),
   OP("Room Temp: 78 F",nothing),
   OP("Room Humidity: 32 %",nothing),
   OP("Status: Idle",nothing)
);

MENU(actionMenu,"Action",
   OP("Fill",fillCmd),
   OP("Empty",emptyCmd)
);

MENU(setupMenu,"Setup",
   FIELD(ConfigID,"Unit ID","",0,99,-10,-1,updateConfigID),
   OP("Set Date/Time",nothing)
);

MENU(mainMenu,"Main",
  SUBMENU(showSensorData),
  SUBMENU(actionMenu),
  SUBMENU(setupMenu)
);

//FIELD(ConfigID,"Unit ID","",0,99,-10,-1,updateConfigID),

int updateWaterTempAlarm() {
  return 1;
}

RF24 radio(9,10);
// Radio pipe addresses for the 2 nodes to communicate.
const uint64_t pipes[2] = { 0xF0F0F0F0E1LL, 0xF0F0F0F0D2LL };

void sendCallback(unsigned short callback){
   // First, stop listening so we can talk
   radio.stopListening();

   // Send the final one back.
   radio.write( &callback, sizeof(unsigned short) );
   printf("Sent response.\n\r");

   // Now, resume listening so we catch the next packets.
   radio.startListening();
}

int old_button = 0;

int read_keyboard() {
  int button, button2, pressed_button;  
  button = getButton();
  if (button != old_button) {
      delay(50);        // debounce
      button2 = getButton();

      if (button == button2) {
         old_button = button;
         pressed_button = button;
         if(button != 0) {
           //Serial.println(button); 
           if(button == 1) return btnLEFT;
           if(button == 2) return btnUP;
           if(button == 3) return btnDOWN;
           if(button == 4) return btnRIGHT;
           if(button == 5) return btnENTER;
         }
      }
  }else{
    return btnNONE;
  }
}

int read_keyboard1() {
  int button, button2, pressed_button;  
  button = getButton();
  if(button != 0) { 
    //Serial.println(button);
    if(button == 1) return btnLEFT;
    if(button == 2) return btnUP;
    if(button == 3) return btnDOWN;
    if(button == 4) return btnRIGHT;
    if(button == 5) return btnENTER;
  }else{
    return btnNONE;
  }
}

int getButton() {
  int i, z, button;
  int sum = 0;

  for (i=0; i < 4; i++) {
     sum += analogRead(keyboard_AnalogInput);
  }
  z = sum / 4;
  if (z > 1000) button = 0;                                           
  else if (z >= 0 && z < 20) button = 1; //LEFT                    
  else if (z > 135 && z < 155) button = 2; //UP                
  else if (z > 315 && z < 335) button = 3; //DOWN                
  else if (z > 495 && z < 515) button = 4; //RIGHT           
  else if (z > 725 && z < 745) button = 5; //ENTER
  else button = 0;

  return button;
}

genericKeyboard mykb(read_keyboard);
 
//Stream* in2[]={&mykb,&Serial};
//chainStream<2> allIn(in2);

void performAction(unsigned char rawMessage){
   unsigned short action, piid, deviceid, callback;
   
   //int input_number = int(rawMessage);
   //action = (input_number%10);
   //deviceid = ((input_number/10)%10);
   //piid = ((input_number/100)%10);

   //if (action == 0 || action ==1){
   //   callback = action;
   //   doAction(piid, deviceid, action);
   //}else if(action == 2){
   //   callback = getState(piid, deviceid);
   //}
   callback=0;
   sendCallback(callback);
}

void loopRadio() {
   // if there is data ready
   if ( radio.available() ){
      // Dump the payloads until we've gotten everything
      unsigned short message;
      bool done;
      // char * new;
      //unsigned short rawMessage; 
      unsigned char rawMessage;
      done = false;
      while ( radio.available() ){
        // Fetch the payload, and see if this was the last one.
        radio.read( &rawMessage, sizeof(unsigned long) );
        // Spew it
        printf("Got message %d...",rawMessage); 
        Serial.println(rawMessage);
        performAction(rawMessage);
        delay(10);
      }
   } 
}

int intWaterTemp, intOldWaterTemp;
void readTemperature() {
  sensors.requestTemperatures();
  intWaterTemp = sensors.getTempFByIndex(0);
  //Serial.println(intWaterTemp);
  if(intOldWaterTemp != intWaterTemp && intWaterTemp != 185 && intWaterTemp != -196) {
    String strWaterTempPre = "Water Temp: ";
    String strWaterTemp = String(intWaterTemp);
    String strJoinedString = strWaterTempPre+strWaterTemp+" F";
    //Serial.println(strJoinedString);
    //Serial.println("----");
    int str_len = strJoinedString.length() + 1;
    char charWaterTemp[str_len];
    strJoinedString.toCharArray(charWaterTemp, str_len);
    Serial.print(charWaterTemp);
    displayTime();
    showSensorData.data[1]->text = charWaterTemp;
    intOldWaterTemp = intWaterTemp;
    showSensorData.redraw(menu_lcd,mykb);
  }
}

String curWaterDepthVal, lastWaterDepthVal;
void readWaterDepth() {
  int curVal = analogRead(depthHighID);
  if(curVal > 500){
    curWaterDepthVal = "High";
  }else{
    curWaterDepthVal = "Low"; 
  }
  if(lastWaterDepthVal != curWaterDepthVal) {
    String strWaterLevelPre = "Water Level: ";
    String strWaterLevel = String(curWaterDepthVal);
    String strJoinedString = strWaterLevelPre+strWaterLevel;
    //Serial.println(strJoinedString);
    //Serial.println("----");
    int str_len = strJoinedString.length() + 1;
    char charWaterLevel[str_len];
    strJoinedString.toCharArray(charWaterLevel, str_len);
    Serial.print(charWaterLevel);
    displayTime();
    showSensorData.data[0]->text = charWaterLevel;
    lastWaterDepthVal = curWaterDepthVal;
    showSensorData.redraw(menu_lcd,mykb);
  }
}

void setup() {
  //delay(1000);
  Serial.begin(9600);
  readConfig();
   
  Wire.begin();
  lcd.begin(20,4);
  lcd.print("Ok"); 

  sensors.begin();

  t_checkWaterTemp.onRun(readTemperature);
  t_checkWaterTemp.setInterval(500);

  t_checkWaterDepth.onRun(readWaterDepth);
  t_checkWaterDepth.setInterval(500);

  rtc.begin(); // Start the RTC library code

  /*----( SET the date and time.  Comment OUT these lines after setting )----*/
  // Put these "//" in front of the line you do NOT want to use
  // following line sets the RTC to the date & time this sketch was compiled
     rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  // This line sets the RTC with an explicit date & time, for example to set
  // May 21, 2015 at 6pm you would call: (use 24 hour time)
  //    rtc.adjust(DateTime(2015, 5, 21, 18, 0, 0));
  
  //pinMode(pinEnter,INPUT);//make it an input
  //digitalWrite(pinEnter,HIGH);//activate pull-up on pin 4

  //radio.begin();
  //  radio.setAutoAck(1);                    // Ensure autoACK is enabled
  //radio.setRetries(15,15);

  //radio.openWritingPipe(pipes[1]);
  //radio.openReadingPipe(1,pipes[0]);
  //radio.startListening();
  //radio.printDetails();
}

void displayTime() {
  DateTime now = rtc.now();  // Read data from the RTC Chip

  Serial.print(" at ");
  Serial.print(now.year(), DEC); //
  Serial.print('/');
  Serial.print(now.month(), DEC);
  Serial.print('/');
  Serial.print(now.day(), DEC);
  Serial.print(' ');
  Serial.print(now.hour(), DEC);
  Serial.print(':');
  Serial.print(now.minute(), DEC);
  Serial.print(':');
  Serial.print(now.second(), DEC);
  Serial.println();
}

String curMenu;
String prevMenu;

void loop()
{
  //serial can use numbers or +/- and Enter=* Esc=/ to navigate (nav keys can be redefined)
  mainMenu.poll(menu_lcd,mykb);
  //loopRadio();
  curMenu = ((menu*)menuNode::activeNode)->text;
  if (curMenu == "Sensor Data") {
    if(curMenu != prevMenu){
      intOldWaterTemp = 0;
    }
    prevMenu = curMenu;
    if(t_checkWaterTemp.shouldRun()){
      t_checkWaterTemp.run();
    }
    if(t_checkWaterDepth.shouldRun()){
      t_checkWaterDepth.run();
    }
  }else{
    prevMenu = curMenu;
  }

  //readWaterDepth();
  //readTemperature();
}
