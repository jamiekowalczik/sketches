//Import this phenominal library
#include <EnableInterrupt.h>
#include <EEPROM.h>
#include <SPI.h>
#include "nRF24L01.h"
#include "RF24.h"
#include "printf.h"
#include <stdio.h>
#include "Thread.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Wire.h> 
#include <LiquidCrystal_I2C.h>
#include <menu.h>
#include <genericKeyboard.h>
//#include <chainStream.h>
#include <menuLCDs.h>
#include <menuFields.h>
#include "RTClib.h"
#include "DHT.h"

// Pin Definitions
#define pinEnter A3
#define keyboard_AnalogInput 3
#define btnRIGHT  menu::enterCode
#define btnUP     menu::downCode
#define btnDOWN   menu::upCode
#define btnLEFT   menu::escCode
#define btnENTER  menu::enterCode
#define btnNONE   -1
#define depthHighPin A2
#define depthHighID 2
#define ONE_WIRE_BUS 4
#define DHTPIN 3
#define DHTTYPE DHT11

//Variables containing data we want to keep persistent
int lastConfigID;
int ConfigID;

//Variables for reading/writing persistent data
//Vars for reading & writing settings
byte xeeConfigID;
int addrConfigID = 1;

LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);  // Set the LCD I2C address
menuLCD menu_lcd(lcd,20,4);//menu output device

void nothing() {}

RTC_DS1307 rtc;    // Create a RealTimeClock object
OneWire ourWire(ONE_WIRE_BUS);
DallasTemperature sensors(&ourWire);
DHT dht(DHTPIN, DHTTYPE);

Thread t_checkWaterTemp = Thread();
Thread t_checkWaterDepth = Thread();
Thread t_checkAirTempHumidity = Thread();

void saveConfigID(int i) {
  xeeConfigID = byte(i);
  EEPROM.write(addrConfigID,xeeConfigID);
}

void readConfig() {
  xeeConfigID = EEPROM.read(addrConfigID);
  ConfigID = int(xeeConfigID);
  if (ConfigID < 0 || ConfigID >99){
     ConfigID = 0;
  }
  lastConfigID = ConfigID;
}

void updateConfigID() {
  if (ConfigID != lastConfigID) {
    saveConfigID(ConfigID);
    lastConfigID = ConfigID;
  }
}

void emptyCmd() {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Emptying Reservoir");
  delay(1000);
  lcd.setCursor(0,1);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.setCursor(0,2);
  lcd.print(" ****Completed****  ");
}

void fillCmd() {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Filling Reservoir");
  delay(1000);
  lcd.setCursor(0,1);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.setCursor(0,2);
  lcd.print(" ****Completed****  ");
}

void showSensorInfo() {
  menu_lcd.clear();
  menu_lcd.setCursor(0,0);
  menu_lcd.print("Room Temp: ");
  menu_lcd.print(" F");
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Filling Reservoir");
  delay(1000);
  lcd.setCursor(0,1);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.print(".");
  delay(1000);
  lcd.setCursor(0,2);
  lcd.print(" ****Completed****  ");
}

////// MENU

MENU(subMenuSensorData,"Sensor Data",
   OP("Water Level: ",nothing),
   OP("Water Temp: ",nothing),
   OP("Room Temp: ",nothing),
   OP("Humidity: ",nothing)
);

MENU(actionMenu,"Action",
   OP("Fill",fillCmd),
   OP("Empty",emptyCmd),
   OP("Status: Idle",nothing)
);

MENU(setupMenu,"Setup",
   FIELD(ConfigID,"Unit ID","",0,99,-10,-1,updateConfigID),
   OP("Set Date/Time",nothing)
);

MENU(mainMenu,"Main",
  SUBMENU(subMenuSensorData),
  SUBMENU(actionMenu),
  SUBMENU(setupMenu)
);

/////////////

////// NO MACROS MENU
/**
prompt subSensorDataWaterLevel("Water Level: ",nothing);
prompt subSensorDataWaterTemp("Water Temp: ",nothing);
prompt subSensorDataRoomTemp("Room Temp: ",nothing);
prompt subSensorRoomHumidity("Room Humidity: ",nothing);
prompt* subMenuSensorDataItems[]={&subSensorDataWaterLevel,&subSensorDataWaterTemp,&subSensorDataRoomTemp,&subSensorRoomHumidity};
menu subMenuSensorData("Sensor Data",5,subMenuSensorDataItems);

prompt subActionFill("Fill",fillCmd);
prompt subActionEmpty("Empty",emptyCmd);
prompt subStatus("Status: Idle",nothing);
prompt* subMenuActionItems[]={&subActionFill,&subActionEmpty,&subStatus};
menu subMenuAction("Action",2,subMenuActionItems);

prompt subSetupUnitID("Unit ID");
prompt subSetupSetDateTime("Set Date/Time");
prompt* subMenuSetupItems[]={&subSetupUnitID,&subSetupSetDateTime};
menu subMenuSetup("Setup",2,subMenuSetupItems);

prompt* mainMenuDataItems[]={&subMenuSensorData,&subMenuAction,&subMenuSetup};
menu mainMenu("Main menu",3,mainMenuDataItems);
**/
/////////////////////

int updateWaterTempAlarm() {
  return 1;
}

RF24 radio(9,10);
// Radio pipe addresses for the 2 nodes to communicate.
const uint64_t pipes[2] = { 0xF0F0F0F0E1LL, 0xF0F0F0F0D2LL };

void sendCallback(unsigned short callback){
   // First, stop listening so we can talk
   radio.stopListening();

   // Send the final one back.
   radio.write( &callback, sizeof(unsigned short) );
   printf("Sent response.\n\r");

   // Now, resume listening so we catch the next packets.
   radio.startListening();
}

int old_button = 0;

int read_keyboard() {
  int button, button2, pressed_button;  
  button = getButton();
  if (button != old_button) {
      delay(50);        // debounce
      button2 = getButton();

      if (button == button2) {
         old_button = button;
         pressed_button = button;
         if(button != 0) {
           //Serial.println(button); 
           if(button == 1) return btnLEFT;
           if(button == 2) return btnUP;
           if(button == 3) return btnDOWN;
           if(button == 4) return btnRIGHT;
           if(button == 5) return btnENTER;
         }
      }
  }else{
    return btnNONE;
  }
}

int read_keyboard1() {
  int button, button2, pressed_button;  
  button = getButton();
  if(button != 0) { 
    //Serial.println(button);
    if(button == 1) return btnLEFT;
    if(button == 2) return btnUP;
    if(button == 3) return btnDOWN;
    if(button == 4) return btnRIGHT;
    if(button == 5) return btnENTER;
  }else{
    return btnNONE;
  }
}

int getButton() {
  int i, z, button;
  int sum = 0;

  for (i=0; i < 4; i++) {
     sum += analogRead(keyboard_AnalogInput);
  }
  z = sum / 4;
  if (z > 1000) button = 0;                                           
  else if (z >= 0 && z < 20) button = 1; //LEFT                    
  else if (z > 135 && z < 155) button = 2; //UP                
  else if (z > 315 && z < 335) button = 3; //DOWN                
  else if (z > 495 && z < 515) button = 4; //RIGHT           
  else if (z > 725 && z < 745) button = 5; //ENTER
  else button = 0;

  return button;
}

genericKeyboard mykb(read_keyboard);
 
//Stream* in2[]={&mykb,&Serial};
//chainStream<2> allIn(in2);

void performAction(unsigned char rawMessage){
   unsigned short action, piid, deviceid, callback;
   
   //int input_number = int(rawMessage);
   //action = (input_number%10);
   //deviceid = ((input_number/10)%10);
   //piid = ((input_number/100)%10);

   //if (action == 0 || action ==1){
   //   callback = action;
   //   doAction(piid, deviceid, action);
   //}else if(action == 2){
   //   callback = getState(piid, deviceid);
   //}
   callback=0;
   sendCallback(callback);
}

void loopRadio() {
   // if there is data ready
   if ( radio.available() ){
      // Dump the payloads until we've gotten everything
      unsigned short message;
      bool done;
      // char * new;
      //unsigned short rawMessage; 
      unsigned char rawMessage;
      done = false;
      while ( radio.available() ){
        // Fetch the payload, and see if this was the last one.
        radio.read( &rawMessage, sizeof(unsigned long) );
        // Spew it
        printf("Got message %d...",rawMessage); 
        Serial.println(rawMessage);
        performAction(rawMessage);
        delay(10);
      }
   } 
}

char charWaterTemp[20];
int intWaterTemp, intOldWaterTemp;
void readTemperature() {
  sensors.requestTemperatures();
  intWaterTemp = sensors.getTempFByIndex(0);
  //Serial.println(intWaterTemp);
  if(intOldWaterTemp != intWaterTemp && intWaterTemp != 185 && intWaterTemp != -196) {
    String strWaterTempPre = "Water Temp: ";
    String strWaterTemp = String(intWaterTemp);
    String strJoinedString = strWaterTempPre+strWaterTemp+" F";
    //Serial.println(strJoinedString);
    //Serial.println("----");
    int str_len = strJoinedString.length() + 1;
    charWaterTemp[str_len];
    strJoinedString.toCharArray(charWaterTemp, str_len);
    Serial.print(charWaterTemp);
    displayTime();
    subMenuSensorData.data[1]->text = charWaterTemp;
    intOldWaterTemp = intWaterTemp;
    subMenuSensorData.redraw(menu_lcd,mykb);
  }
}

String curWaterDepthVal, lastWaterDepthVal;
char charWaterLevel[20];
void readWaterDepth() {
  int curVal = analogRead(depthHighID);
  if(curVal > 625){
    curWaterDepthVal = "High";
  }else{
    curWaterDepthVal = "Low"; 
  }
  if(lastWaterDepthVal != curWaterDepthVal) {
    String strWaterLevelPre = "Water Level: ";
    String strWaterLevel = String(curWaterDepthVal);
    String strJoinedString = strWaterLevelPre+strWaterLevel;
    //Serial.println(strJoinedString);
    //Serial.println("----");
    int str_len = strJoinedString.length() + 1;
    charWaterLevel[str_len];
    strJoinedString.toCharArray(charWaterLevel, str_len);
    Serial.print(charWaterLevel);
    displayTime();
    subMenuSensorData.data[0]->text = charWaterLevel;
    lastWaterDepthVal = curWaterDepthVal;
    subMenuSensorData.redraw(menu_lcd,mykb);
  }
}

char charRoomTemp[20];
char charRoomHumidity[20];
int intRoomTemp, intOldRoomTemp, intRoomHumidity, intOldRoomHumidity;
float fRoomTemp, fRoomHumidity;
void readRoomTemperatureAndHumidity() {
  float fRoomHumidity = dht.readHumidity();
  float fRoomTemp = dht.readTemperature(true);
  intRoomTemp = (int) fRoomTemp;
  intRoomHumidity = (int) fRoomHumidity;
  
  if (isnan(fRoomHumidity) || isnan(fRoomTemp)) {
    Serial.println("Failed to read from DHT sensor!");
    return;
  }

  if(intRoomTemp != intOldRoomTemp) {
    String strRoomTempPre = "Room Temp: ";
    String strRoomTemp = String(intRoomTemp);
    String strJoinedString = strRoomTempPre+strRoomTemp+" F";
    //Serial.println(strJoinedString);
    //Serial.println("----");
    int str_len = strJoinedString.length() + 1;
    charRoomTemp[str_len];
    strJoinedString.toCharArray(charRoomTemp, str_len);
    Serial.print(charRoomTemp);
    displayTime();
    subMenuSensorData.data[2]->text = charRoomTemp;
    intOldRoomTemp = intRoomTemp;
    subMenuSensorData.redraw(menu_lcd,mykb);
  }

  if(intOldRoomHumidity != intRoomHumidity) {
    String strRoomHumidityPre = "Humidity: ";
    String strRoomHumidity = String(intRoomHumidity);
    String strJoinedString = strRoomHumidityPre+strRoomHumidity+" %";
    //Serial.println(strJoinedString);
    //Serial.println("----");
    int str_len = strJoinedString.length() + 1;
    charRoomHumidity[str_len];
    strJoinedString.toCharArray(charRoomHumidity, str_len);
    Serial.print(charRoomHumidity);
    displayTime();
    subMenuSensorData.data[3]->text = charRoomHumidity;
    intOldRoomHumidity = intRoomHumidity;
    subMenuSensorData.redraw(menu_lcd,mykb);
  }
}

void readAirTempHumidity() {
  float h = dht.readHumidity();
  // Read temperature as Celsius (the default)
  float t = dht.readTemperature();
  // Read temperature as Fahrenheit (isFahrenheit = true)
  float f = dht.readTemperature(true);

  // Check if any reads failed and exit early (to try again).
  if (isnan(h) || isnan(t) || isnan(f)) {
    Serial.println("Failed to read from DHT sensor!");
    return;
  }

  // Compute heat index in Fahrenheit (the default)
  float hif = dht.computeHeatIndex(f, h);
  // Compute heat index in Celsius (isFahreheit = false)
  float hic = dht.computeHeatIndex(t, h, false);

  Serial.print("Humidity: ");
  Serial.print(h);
  Serial.print(" %\t");
  Serial.print("Temperature: ");
  Serial.print(t);
  Serial.print(" *C ");
  Serial.print(f);
  Serial.print(" *F\t");
  Serial.print("Heat index: ");
  Serial.print(hic);
  Serial.print(" *C ");
  Serial.print(hif);
  Serial.println(" *F");
}

void displayTime() {
  DateTime now = rtc.now();  // Read data from the RTC Chip

  Serial.print(" at ");
  Serial.print(now.year(), DEC); //
  Serial.print('/');
  Serial.print(now.month(), DEC);
  Serial.print('/');
  Serial.print(now.day(), DEC);
  Serial.print(' ');
  Serial.print(now.hour(), DEC);
  Serial.print(':');
  Serial.print(now.minute(), DEC);
  Serial.print(':');
  Serial.print(now.second(), DEC);
  Serial.println();
}

void setup() {
  //delay(1000);
  Serial.begin(9600);
  readConfig();
   
  Wire.begin();
  lcd.begin(20,4);
  lcd.print("Ok"); 

  sensors.begin();

  t_checkWaterTemp.onRun(readTemperature);
  t_checkWaterTemp.setInterval(500);

  t_checkWaterDepth.onRun(readWaterDepth);
  t_checkWaterDepth.setInterval(500);

  t_checkAirTempHumidity.onRun(readRoomTemperatureAndHumidity);
  t_checkAirTempHumidity.setInterval(500);
  
  rtc.begin(); // Start the RTC library code
  dht.begin();
  
  /*----( SET the date and time.  Comment OUT these lines after setting )----*/
  // Put these "//" in front of the line you do NOT want to use
  // following line sets the RTC to the date & time this sketch was compiled
     rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  // This line sets the RTC with an explicit date & time, for example to set
  // May 21, 2015 at 6pm you would call: (use 24 hour time)
  //    rtc.adjust(DateTime(2015, 5, 21, 18, 0, 0));
  
  //pinMode(pinEnter,INPUT);//make it an input
  //digitalWrite(pinEnter,HIGH);//activate pull-up on pin 4

  //radio.begin();
  //  radio.setAutoAck(1);                    // Ensure autoACK is enabled
  //radio.setRetries(15,15);

  //radio.openWritingPipe(pipes[1]);
  //radio.openReadingPipe(1,pipes[0]);
  //radio.startListening();
  //radio.printDetails();
}

String curMenu;
String prevMenu;
void loop()
{
  //serial can use numbers or +/- and Enter=* Esc=/ to navigate (nav keys can be redefined)
  mainMenu.poll(menu_lcd,mykb);
  //loopRadio();
  curMenu = ((menu*)menuNode::activeNode)->text;
  if (curMenu == "Sensor Data") {
    if(curMenu != prevMenu){
      intOldWaterTemp = 0;
      lastWaterDepthVal = "";
      intOldRoomTemp = 0;
      intOldRoomHumidity = 0;
    }
   
    prevMenu = curMenu;
    if(t_checkWaterTemp.shouldRun()){
      t_checkWaterTemp.run();
    }
    if(t_checkWaterDepth.shouldRun()){
      t_checkWaterDepth.run();
    }
    if(t_checkAirTempHumidity.shouldRun()){
      t_checkAirTempHumidity.run();
    }
  }else{
    prevMenu = curMenu;
  }

  //readWaterDepth();
  //readTemperature();
}
